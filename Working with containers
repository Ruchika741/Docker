# Starting containers

- A container is just a process but a special process which has its own file system provided by the image
- docker ps 		//// to see all running containers, ps is processes

- docker run flask-app		//// run the container using flask-app image. But using this command we can not type any additional command in the terminal. If we do ctrl +C to get out of this the container stops

- docker run -d flask-app		//// with this we can run the container in detached mode, which means in the background
- docker ps 			//// you can check if above container is still running

- Docker automatically associates each container with some name
- We can also give name to our container using --name. Here name is blue-sky
- docker run -d --name blue-sky flask-app

# Viewing the logs-

When a container is running in background and you want to check if error generated by server

- docker logs 655 		//// 655 is the first three letters of container id
- docker logs --help
- docker logs -f 655	//// follow log output. Useful when your container is continuously producing output
- docker logs -n 5 655	//// will show last 5 lines of logs. Useful when the logs are very large
- docker logs -n 5 -t 655 	//// if you want to see timestamp in front of each message

# Publishing Ports-

- Currently we have two containers running our flask applications. But if we go to localhost port 3000, we cannot access this application. Because port 5000 is published in the container not on the host
- docker ps     //// will give port details for running containers
- Publish a port lets say 5000 on the host
- docker run -d -p 3000:5000 --name c1 flask-app		//// port 80 of the host is mapped to port 5000 of the container(port forwarding)
- If we go to localhost:3000, we can see our flask app running

# Executing commands in running containers

- With docker run is to start a container and run a new command and docker exec(execute) is to execute a command in a  running container
- docker exec blue-sky ls
- docker exec -it blue-sky sh

# Starting and stopping containers

- docker stop blue-sky
- docker ps

- With docker run you start a new container whereas with docker start you start a stopped container

# Removing Containers

- docker container rm c1
- docker rm c1

- You cannot remove a running container. Either stop it then remove or do force removl
- docker rm -f c1		//// force remove
- docker ps
- docker ps -a
- docker ps -a | grep c1		//// c1 is container name
- docker container prune	//// to get rid of all stopped containers

# Containers File System

- Each container has its own file system which is invisible to other containers
- Eg - create two containers running on the same image. Start a shell session on first container and write something to a newly created file in application directory. Start a new shell session with another container and see if that file is there or not. It won't be visible.
- So we should never store data in a container file system because if we delete this container the file system will go with it and we may loose data. That's why volume is there for.

- docker exec -it conatiner_name1 sh
/app $ touch sample.txt
/app $ vi sample.txt		//// Open the file in edit mode inside shell session
/app $ cat sample.txt
- docker exec -it conatiner_name2 sh
/app $ ls | grep data


Or
- docker exec -it container_name1 sh
/app $ touch sample.txt
/app $ echo data > data.txt
- docker exec -it conatiner_name2 sh
/app $ ls | grep data

# Persisting data using Volume

- Volume is a storage outside the container. It can be a directory in the host or somewhere in the cloud.
- If we delete a container the associated volume is not deleted
- docker volume		//// to see list of volume commands
- docker volume create app-data
- docker volume inspect app-data

- Start a container giving this volume as persistant data
- docker run -d -p 4000:5000 -v app-data:/app/data flask-app		//// map app-data of a directory to file system of container. Here it will automatically create data inside app directory
- docker exec -it container_id sh
- cd data
- echo data > data.txt		//// gives error as can't create data.txt permission denied

- Add RUN mkdir data in Dockerfile and then build image
- docker run -d -p 3000:5000 -v app-data:/app/data flask-app		//// map app-data of a directory to file system of container. Here it will automatically create data inside app directory
- docker exec -it container_id sh
- cd data
- echo data > data.txt		//// it will work
- docker rm -f cont_id
- docker run -d -p 3000:5000 -v app-data:/app/data flask-app	//// start a new container with same volume mapping
- docker exec -it container_id sh
- cd data
- ls  					//// data.txt is present

# Copying files between host and containers

- docker ps
- docker exec -it cont_id sh
- echo hello > log.txt		//// we have this log file inside the app directory inside container
- exit
- docker cp cont_id:/app/log.txt .		//// copy file from container to current directory(host)
- ls
- echo hello > secret.txt				//// this file is in project directory in the host
- docker cp secret.txt cont_id:/app  	//// file gets created inside container's file system. Copied from host.

# Sharing the source code with a container

- Make any change in code and refresh the browser localhost:5000/ It won't display the latest changes.
Publishing changes
- For Production machines we should always build a new image, tag it properly and then deploy
- For development machines- We don't want to build a new image everytime we make a tiny change in the code. That's time consuming. Also, we don't want to manually copy files everytime from our development machine into our container everytime we change our code. The solution can be we can create a mapping/binding between a directory(/project) in the host and a directory in the container(/app)

- docker run -d -p 5001:3000 -v ${pwd}:/app flask-app		//// pwd is current directory that hold our application
- Go to inside app directory of a container
- docker exec -it cont_id sh
- ls -lrt /bin/			//// will display all the libraries inside base image
- wget https://localhost:8000
- ls -lrt		//// the server creates an index.html file that contains proceesed data. In our sample project it is Hello
- cat index.html

# Summary

- Running containers

docker run <image>
docker run -d <image>              # run in the background
docker run —name <name> <image>    # to give a custom name 
docker run —p 3000:3000 <image>    # to publish a port HOST:CONTAINER

- Viewing the logs

docker logs <containerID>
docker logs -f <containerID>       # to follow the log
docker logs —t <containerID>       # to add timestamps
docker logs —n 10 <containerID>    # to view the last 10 lines

- Executing commands in running containers

docker exec <containerID> <cmd>
docker exec -it <containerID> sh   # to start a shell 

- Listing containers

docker ps 							# to list running containers
docker ps -a   						# to list all containers

- Starting and stopping containers

docker stop <containerID> 
docker start <containerID>

- Removing container

docker container rm <containerID> 
docker rm <containerID> 
docker rm -f <containerID>        # to force the removal
docker container prune            # to remove stopped containerss

- Volumes
docker volume ls
docker volume create app-data
docker volume inspect app-data
docker run -v app-data:/app/data <image>

- Copying files between the host and containers

docker cp <containerID>:/app/log.txt .
docker cp secret.txt <containerID>:/app

- Sharing source code with containers

docker run -v $(pwd):/app <image>


