- Docker is built on basic docker concepts

# Linux distributions/Linux Distros

- A Linux distribution, often referred to as a Linux distro, is a complete operating system based on the Linux kernel and bundled with various software applications and utilities.
- It's a combination of the Linux kernel, system libraries, user interface components, and a collection of software packages that provide functionality for different purposes.
- Linux distributions are created and maintained by individuals, organizations, or communities with the goal of providing a complete and ready-to-use operating system that can be installed on a computer or server
-  Each distribution typically has its own goals, target audience, and specific features.
- In linux we use forward slash to seperate files and directories whereas in windows we use backward slash. Linux is a case sensitive operating system

Eg of Linux distros are Ubuntu, Debian, Alpine, Fedora, Centos

- Ubuntu: A widely-used Linux distribution known for its user-friendliness and extensive community support. It has different editions tailored for desktop, server, and cloud environments.

- Fedora: A community-driven distribution sponsored by Red Hat. It focuses on providing the latest open-source software and technologies.

- Debian: One of the oldest and highly respected distributions. It emphasizes stability, security, and free software principles. Ubuntu itself is based on Debian.

- CentOS: A distribution derived from the source code of Red Hat Enterprise Linux (RHEL). It aims to provide a free and open-source alternative with long-term support.

/////////////////////////

- Go to docker hub and search for ubuntu image
- Go to cmd-> docker run ubuntu /// it will pull latest ubuntu image from docker hub. Docker started a container but we didn't interact with it so the docker stopped.
- docker ps /////// it shows list of container running. will not show ubuntu container running
- docker ps -a //////// will show all containers running and stopped. you will find ubuntu here
- docker run -it ubuntu   /////// to start a container in interactive mode. This will open a shell. A shell is a program that takes our command and passes them to the OS for execution
- root@855d05353166:/#
here root -> by default we are logged in as a root user which has the highest privilages
	 855d05353166 -> Name of the machine. This container has this id 855d05353166 which is automatically generated by docker.
	 / -> this forward slash represents where we are in file system. It represents the root directory. It's the highest directory in file system
	 # -> means I have the highest privilages as I have logged in as a root user. For normal user it would be $ sign
- Commands to execute in shell
	- echo hello
	- whoami
	- echo $0  ////we can see location of this shell program
	- history  ///will give all the latest commands executed
	- !2       ///will execute second command from history


/////////////////////////////

# Navigating the Linux File system

- pwd     //// print working directory. Forward slash / represents the root directory
- ls      //// to show list of files and directories
- ls -l   //// list with more details
- ls -a   //// lists all the hidden files and directories as well
- cd      //// change directory by giving absolute or relative path
- cd ..   //// to get out of the directory by one level up
- cd ../..   //// to get out of the directory by two level up
- ls /bin    //// to get list of files and directory by giving absolute or relative path
- there are two types of directories root and home. Every user has their home directory. By default initially it's root directory. But root user has special home directory called root
- cd /         //// will take you to root directory
- cd ..      //// to get out of root directory
- cd ~       //// to go to home directory

# Manipulating Files and directories-

go to home directory
- cd ~
- mkdir test
- ls
- mv test docker  //// move the file/dir path or rename it
- ls
- cd /docker/
- touch hello.txt   //// to create a file
- ls
- touch file1.txt file2.txt file3.txt   //// to create multiple files in one go
- ls
- ls -1     //// will list the files with single file per line
- rm file1.txt file2.txt    //// to remove 1 or multiple files
- rm file*  //// remove all files that starts with file
- cd ..
- rm -r docker/      //// to remove a directory and all its files recursively

# Editing and Viewing files

- nano is a basic text editor for Linux
- command to install nano on image that you are running
- apt update     //// updating the package lists on your system
- apt install nano
- nano file1.txt
- Exit using ctl+X - Yes to keep changes
- cat file1.txt    //// to see content of the file. Usefule when you have only one page content
- more etc/adduser.conf   //// to see content of the file. Usefule when you have more than one page content. Use space to go to next page. Use enter to get one more line.
- apt install less   //// command to replace more. We can use up and down arrow to scroll
- less etc/adduser.conf 
- head -n 5 etc/adduser.conf  //// n is number of line, we want to see here first 5 lines
- tail -n 5 etc/adduser.conf  //// n is number of line, we want to see here first 5 lines

# Redirection

- concept of standard input and output
- standard input represents the input and standard output reppresents the screen
- We can always change the source of input or output this is called redirection

- cat file1.txt > file2.txt  //// here cat will read the content of file1.txt and copy it to file2.txt
- cat file1.txt file2.text	 //// here cat will combine data of both the files and print as output
- cat file1.txt file2.txt > combined.txt
- echo hello > hello.txt     //// echo used to write single line to hello.txt
- ls -l /etc > files.txt     //// to get long listing of files in etc directory and write the output to a file

# Searching text in files

- grep Hello hello.txt  //// global regular expressionb print command. this search is case sensitive
- grep -i Hello hello.txt  //// add -i to make the search case insensitive
- grep -i Hello file1.txt file2.txt  //// search in multiple files
- grep -i Hello file*    //// search in all files whose name starts with file
- grep -i -r hello .     //// here we want to search the text in current directory and in all its sub directories recursively, hence -r is used which stands for recursive
- grep -ir hello .		//// equivalent to above command

# Finding files and directories

- find   //// find all the files and directories in the current directory recursively
- find /etc
- find -type d  //// displays all directories only in current directory
- find -type f  //// displays all files only in current directory
- find -type f -name "f*" //// displays all files whose name starts with f
- find -type f -iname "f*" //// displays all files whose name starts with f or F(case insensitive)
- find / -type f -name "*.py"  //// will find all python file in this image
- find / -type f -name "*.py" > pythonfile.txt   //// to write to some text file

# Chaining commands

- mkdir test ; cd test ; echo Hello  //// commands will run from left to right
- cd ..
- mkdir test ; cd test ; echo Hello  //// on again running the command it will throw error for first and run the other two
- mkdir test && cd test && echo Hello  //// if the first command fails other won't get executed using &&
- mkdir test || echo "directory exists"  //// if first command gets executed the other won't get executed. And if first fails the other will get executed

- ls /bin | less    //// pipe command is used here to get the output lists of /bin and send it to less. Here less doesn't need any file name because it gets all from previous command
- ls /bin | head
- ls /bin | head -n 5

# breaking long command into multiple lines - use a backslash and enter
- mkdir hello;\
> cd hello; \
> echo done

# Environment variables- 

- we can set environment variables in linux to store configuration details of our application.
- printenv  //// display all env variables set in the machine
- printenv PATH  //// to read value of a particular variable
- echo $PATH     //// to read value of a particular variable
- export DB_USER=ruchika    //// to set value for a variable for the current session of terminal
- echo $DB_USER
- exit      //// you can exit from the current session
- docker ps -a  //// get the container id
- docker start -i container_id  //// will start running the container
- echo $DB_USER  //// will not show anything as the variable donot exist anymore in the new session

- To make the variables value persistant, create a file
- go to home directory
- cd ~   
- ls -a   //// .bashrc is a file created in home directory for user
- echo DB_USER=ruchika >> .bashrc   //// will right the value in append mode to .bashrc. If we just use > then it will replace the content of .bashrc with what we have given here
- exit
- docker start -i container_id 
- echo $DB_USER //// you will get the value as ruchika here. This will remain for this particular container

- cd ~    //// go to home directory
- echo COLOR=blue >> .bashrc
- echo $COLOR   //// you won't get the value because .bashrc is loaded once when we start the terminal session. To get the value either terminate the current session using exit and again start the container or use source to reload the .bashrc file
- source .bashrc     //// always execute from home directory
- source ~/.bashrc  //// if you are not in home directory
- echo $COLOR

- Never store sensitive information like password in env variables as these are stored in form of plain text

# Managing Processes

- Process is an instance of running program
- cd ~
- ps  //// to see all the running program/process
- bash is short for born and shell. It's the program that we are interacting with here, the program that takes our commands and send them to linux for execution
- sleep 3
- sleep 100 &  /// to run the sleep in background
- ps  //// you will see sleep running in background. It's a light process as it's not taking much of CPU time
- kill 38  //// 38 is process id which we get from above command to kill the process
- ps


# Managing Users

- useradd/usermod/userdel

- useradd
- useradd -m john
- cat /etc/passwd 	//// john is added in the last with details like username -> colon as separator -> x means password is stored somewhere else -> user id is 1000 -> group id is 1000 -> home directory of this user /home/john -> we have program used when this user logs in /bin/sh represents the old original shell program but we also have bash which is enhanced version of this shell
- Let's say when I login I want to use bash instead of this shell, then we will use usermod to modify it
- usermod
- usermod -s /bin/bash john			 //// -s is for setting the shell for this user
- cat /etc/passwd

- cat /etc/shadow          //// stores password in encrypted format and only accessible to root user

- adduser bob    			//// similar to useradd but more interactive

- Now lets say we want to login as john
- open a new terminal and login to our container as john
- docker ps
- docker exec -it container_id bash	//// execute a bash session inside this container. This will login as root user
- exit
- docker exec -it -u john container_id bash	//// execute a bash session inside this container. This will login as john user
- cat /etc/shadow		//// permission denied error
- cd ~  				//// john's home directory
- pwd


# Managing groups

- groupadd/groupmod/groupdel
- cd ~
- groupadd developers
- cat /etc/group       //// to see the group added
- useradd john
- cat etc/passwd
- In linux every user has one primary group(-g) and 0 or more secondary(supplementary)(-G) groups. Primary group is automatically created when we create a user. It's the group with same name as user.
- usermod -G developers john  		//// add john to group developers
- cat /etc/group
- grep john /etc/passwd
- groups john   //// john is part of two groups one is john which is primary group and other is developers which is supplementary group
- usermod -aG artist,developers john  //// add john to multiple groups

# File permissions

- cd /home/
- echo echo hello > deploy.sh
- cat deploy.sh    //// file with .sh is called shell scripts. We can write and linux command inside this file
- ls -l 		//// to see the permission of this file we have to get long listing
- if the line start in the output for above starts with d that means its a directory and if it starts with - then its a file
Eg -> -rw-r--r-- 1 root root 11 Jul 17 02:56 deploy.sh
-here starting - means its a file
-there are three group permissions here rw- for 1st group r-- for 2nd group and r-- for 3rd group
-In each group we have read(r), write(w) and execute(x) permission
-By default each directory will have execute permission so that we can go inside it
-the first group represents the permission for user who owns this file(here root)
-the second group represents the permission for the group who owns this file(here root)
-the third group represents the permission for everyone else
- ./deploy.sh    //// to execute this file
- it will show as permission denied because we don't have execute permission for this file. This is where we use change mode command
- chmod u/g/o   //// for user/group/others
- chmod u+x deploy.sh 		//// to add the execute permission to user and to remove use u-x
- ls -l
- ./deploy.sh
- chmod og+x+w-r		//// change permissions for both others and group

# Summary-

- The Linux Command Line

apt update 
apt list 
apt install nano
apt remove nano

- Managing packages

pwd          # to print the working directory
ls           # to list the files and directories
ls -l        # to print a long list
cd /         # to go to the root directory
cd bin       # to go to the bin directory
cd ..        # to go one level up
cd ~         # to go to the home directory Navigating the file system

- Manipulating files and directories

mkdir test              # to create the test directory
mv test docker          # to rename a directory 
touch file.txt          # to create file.txt
mv file.txt hello.txt   # to rename a file 
rm hello.txt            # to remove a file 
rm -r docker            # to recursively remove a directory

- Editing and viewing files

nano file.txt        # to edit file.txt
cat file.txt         # to view file.txt
less file.txt        # to view with scrolling capabilities
head file.txt        # to view the first 10 lines
head -n 5 file.txt   # to view the first 5 lines 
tail file.txt        # to view the last 10 lines 
tail -n 5 file.txt   # to view the last 5 lines 

- Searching for text 

grep hello file.txt        # to search for hello in file.txt
grep -i hello file.txt     # case-insensitive search 
grep -i hello file*.txt    # to search in files with a pattern
grep -i -r hello .         # to search in the current directory     

- Finding files and directories

find         # to list all files and directories
find -type d       # to list directories only
find -type f       # to list files only
find -name “f*”    # to filter by name using a pattern

- Managing environment variables

printenv           # to list all environment variables and their value
printenv PATH      # to view the value of PATH
echo $PATH         # to view the value of PATH
export name=bob    # to set a variable in the current session

- Managing processes

ps                 # to list the running processes
kill 37            # to kill the process with ID 37

- Managing users and groups

useradd -m john    # to create a user with a home directory
adduser john       # to add a user interactively
usermod            # to modify a user
userdel            # to delete a user
groupadd devs      # to create a group 
groups john        # to view the groups for john
groupmod           # to modify a group
groupdel           # to delete a group

chmod u+x deploy.sh    # give the owning user execute permission
chmod g+x deploy.sh    # give the owning group execute permission
chmod o+x deploy.sh    # give everyone else execute permission
chmod ug+x deploy.sh   # to give the owning user and group execute permission
chmod ug-x deploy.sh   # to remove the execute permission from the owning user and group File permissions





